import java.util.*; 
import java.util.stream.Collectors; 
import java.util.stream.Stream; 
import java.util.stream.IntStream; 

class Arc{
  private Node n;
  private int d;
  
  Arc(Node n, int d){
    this.n=n;
    this.d=d;
  }
  
  public int getDistance(){
    return this.d;
  }
  
  public Node getNode(){
    return this.n;
  }

}

class Node{
   private int value=Integer.MAX_VALUE;
   private boolean inOpened=false;
   private boolean inClosed=false;
   private float costSS=0; //effectif cost since Start
   private float costUE=0; //Theorical cost until the end;
   private float heuCost=0; //heuristic cost;
   private Node parent=null;
  
  private List<Arc>arcs=new ArrayList<>();
   
   public void generateHeuCost(){
       this.heuCost=this.costSS+this.costUE;
   } 
   
   Node(String value){
        this.value=Integer.valueOf(value);
   }
   
   Node(int value){
        this.value=value;
   }
   
   public int getValue(){
       return this.value;
   }
   
  public void setCostUntilEnd(float costUE){
         this.costUE=costUE;
   }
   public void updateCost(float costSS){
         this.costSS=costSS;
   }
   
   public void setOpenedList(){
         inOpened=true;
   }
   
   public void setClosedList(){
         inClosed=true;
   }
   
   public void setNotOpenedList(){
         inOpened=false;
   }
   public boolean isInOpenedList(){
         return inOpened;
   }
   
   public boolean isInClosedList(){
         return inClosed;
   }
   
   public float getHeuCost(){
       return heuCost;
   }
   
   public float getCost(){
       return this.costSS;
   }
   
   public void add(Node n){
       this.arcs.add(new Arc(n,Math.abs(n.getValue()-this.getValue())));
   
   }
   
   public void setParent(Node parent){
       this.parent=parent;
   }
   
   public Node getParent(){
       return this.parent;
   } 
   
   public List<Arc> getArcs(){
       return arcs;
   
   }
   
   public void setArcs(List<Arc> arcs){
     this.arcs=arcs;
   }
}

class Graph{
    private int n;
    private Node[][] nodes;
    private List<Node> openedList=new ArrayList<>();
    private List<Node> closedList=new ArrayList<>();
  
    
    public Graph(String maze){
        nodes=strToArray(maze);
        createArcs();
        
    }
     
    private Node[][] strToArray(String maze){
      return Arrays.stream(maze.split("\n"))
                       .map(line->Arrays.stream(line.split("")).map(Node::new).toArray(Node[]::new))
                       .toArray(Node[][]::new);
    }
    
    private void createArcs(){
          n=nodes.length;
         for(int i=0;i<n;i++){
                 int n2=nodes[i].length;
             for(int j=0;j<n2;j++){
                   float dist=0;
                   nodes[i][j].setCostUntilEnd(dist);
                   if((i==0||i==n-1)&&j!=0&&j!=n2-1){
                       int dir=(i==0?1:-1);
                       nodes[i][j].add(nodes[i+dir][j]);
                       nodes[i][j].add(nodes[i][j+1]);
                       nodes[i][j].add(nodes[i][j-1]);
                   }
                   else{
                        if((j==0||j==n2-1)&&i!=0&&i!=n-1){
                           int dir=(j==0?1:-1);
                           nodes[i][j].add(nodes[i][j+dir]);
                           nodes[i][j].add(nodes[i+1][j]);
                           nodes[i][j].add(nodes[i-1][j]);
                        }
                        else{
                            if(i==0&&j==0){//top left corner
                              nodes[i][j].add(nodes[i+1][j]);
                              nodes[i][j].add(nodes[i][j+1]);
                            }
                            else{
                                if(i==0&&j==n2-1){//top righ corner
                                  nodes[i][j].add(nodes[i][j-1]);
                                  nodes[i][j].add(nodes[i+1][j]);
                                }
                                else{
                                  if(i==n-1&&j==n2-1){//bottom right corner
                                     nodes[i][j].add(nodes[i-1][j]);
                                     nodes[i][j].add(nodes[i][j-1]);
                                  }
                                  else{
                                     if(i==n-1&&j==0){//bottom left corner
                                       nodes[i][j].add(nodes[i-1][j]);
                                       nodes[i][j].add(nodes[i][j+1]);
                                     }
                                     else{
                                         nodes[i][j].add(nodes[i][j+1]);
                                         nodes[i][j].add(nodes[i][j-1]);
                                         nodes[i][j].add(nodes[i+1][j]);
                                         nodes[i][j].add(nodes[i-1][j]);
                                     
                                     }
                                  }
                               }
                          }
                      }
                 }
             }
        }
   }
    public Node[][] getArray(){
        return nodes;
    }
    private void addOpenL(Node n){
        if(!n.isInClosedList()){
              if(!n.isInOpenedList()){
                  n.setOpenedList();
                  openedList.add(n);
                  openedList.sort(Comparator.comparingDouble(Node::getHeuCost));
              }
            
        }
    
    }
    
     private void addClosedL(Node n){
        if(!n.isInClosedList()){
              if(n.isInOpenedList()){
                  n.setClosedList();
                  closedList.add(n);
                  if(openedList.size()>0){
                      openedList.remove(n);
                  }
              }
        }
    
    }
   //need check is null
   private Node getCurrElem(){
       return closedList.size()>0?closedList.get(closedList.size() - 1):null;
   }
   
   private Node bestChoise(){
       return openedList.size()>0?openedList.get(0):null;
   }
   
   public int path(){
             Node currNode;
             addOpenL(nodes[0][0]);
             addClosedL(nodes[0][0]);
             Node bChoise=null;
             currNode=getCurrElem();
             int min=Integer.MAX_VALUE;
             do{
               for(int i=0;i<currNode.getArcs().size();i++){
                     Arc a= currNode.getArcs().get(i);
                     Node n=a.getNode();
                     n.updateCost(a.getDistance()+currNode.getCost());
                     n.generateHeuCost();
                     n.setParent(currNode);
                     addOpenL(n);
                     
               }
               bChoise=bestChoise();
               
               if(bChoise!=null){
                    addClosedL(bChoise);
                    currNode=getCurrElem();
               }  
             }
             while(bChoise!=null&&bChoise!=nodes[n-1][n-1]);
           
           if(bChoise==nodes[n-1][n-1]){
                return (int)bChoise.getCost();
            }
            return 0;
   }
}

public class Finder {
    static int pathFinder(String maze) {
        System.out.println(maze);
        System.out.println();
        if(maze.length()>1){
            Graph A=new Graph(maze);
            return  A.path();
        }
        return 0;
    }
}
