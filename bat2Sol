using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;

/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/
class Player
{
     static int oldX;
     static int oldY;
     static int oldMaxY;
     static int oldMinY;
     static int oldMaxX;
     static int oldMinX;
     static void moveOnAxis(int sens,ref int min,ref int max,ref int val,ref int oldVal,ref int oldMinVal,ref int oldMaxVal){
            oldVal=val;
            oldMaxVal=max;
            oldMinVal=min;
            
            if(sens==1){//RIGHT
                min=val;
                val=(val+max)/2;
            }
            else{  //LEFT
                max=val;
                val=(val+min)/2;
            }
     }
     
     static void moveY(ref int y,ref int max,ref int min,ref int sens,int H){
        
         moveOnAxis(sens,ref min,ref max,ref y,ref oldY,ref oldMinY,ref oldMaxY);

     }
     
     static void moveX(ref int x,ref int max,ref int min,ref int sens,int W){
         
          moveOnAxis(sens,ref min,ref max,ref x,ref oldX,ref oldMinX,ref oldMaxX);
          
     }
     
     static void reverseX(ref int sens,ref int min,ref int max,ref int val,int W){
         if(!((val==0&&sens==1)||(val==W-1&&sens==-1)))
         reverseDir(ref sens,ref min,ref max,ref val,ref oldX,ref  oldMinX,ref  oldMaxX);
        else{
           moveX(ref val,ref min,ref max,ref sens, W);
         Console.Error.WriteLine("ici "+val+ "min "+min+" max "+max+"");
         }
         
     }
     
     static void reverseY(ref int sens,ref int min,ref int max,ref int val,int H){
       if(!((val==H-1&&sens==1)||(val==0&&sens==-1)))
         reverseDir(ref sens,ref min,ref max,ref val,ref oldY,ref  oldMinY,ref oldMaxY);
       else
        moveY(ref val,ref min,ref max,ref sens, H);
     }
     
      static void reverseDir(ref int sens,ref int min,ref int max,ref int val,ref int oldVal,ref int oldMinVal,ref int oldMaxVal){
           
             sens*=-1;
                if(sens==1){
                    min=val;
                    max=oldMaxVal;
                }
                else{
                    min=oldMinVal;
                    max=val;
                }
                val=oldVal;
          
          moveOnAxis(sens,ref min,ref max,ref val,ref oldVal,ref oldMinVal,ref oldMaxVal);
}
     static void moveX(ref int x,ref int max,ref int min,int sens){
            oldX=x;
            oldMaxX=max;
            oldMinX=min;
            
            if(sens==1){//RIGHT
                min=x;
                x=(x+max)/2;
            }
            else{  //LEFT
                max=x;
                x=(x+min)/2;
            }
     }
    
     static void moveY(ref int y,ref int max,ref int min,int sens){
            oldY=y;
            oldMaxY=max;
            oldMinY=min;
            if(sens==1){//UP
              
                y=(y+max)/2;
                min=y;
            }
            else{//DOWN
                y=(y+min)/2;
                max=y;
            }
     }
     static void moveToMiddle(ref int x,ref int y, int w, int h){
        x=w/2;
        y=h/2;
        
    }
    static void Main(string[] args)
    {
        string[] inputs;
        inputs = Console.ReadLine().Split(' ');
        int W = int.Parse(inputs[0]); // width of the building.
        int H = int.Parse(inputs[1]); // height of the building.
        int N = int.Parse(Console.ReadLine()); // maximum number of turns before game over.
        inputs = Console.ReadLine().Split(' ');
        int X0 = int.Parse(inputs[0]);
        int Y0 = int.Parse(inputs[1]);
        int minX=0,maxX=W;
        int minY=H,maxY=0;
        int sensX=1;
        int sensY=1;
        bool moveOnY=false;
        bool axeChange=false;
        bool properDir=false;
       
        // game loop
        while (true)
        {
            string bombDir = Console.ReadLine(); // Current distance to the bomb compared to previous distance (COLDER, WARMER, SAME or UNKNOWN)
            Console.Error.WriteLine("x:"+X0+" min: "+minX+" max: "+maxX+" sens "+ sensX);
            Console.Error.WriteLine("Y:"+Y0+" min: "+minY+" max: "+maxY+" sens "+ sensY);
            Console.Error.WriteLine("bombDir:"+bombDir);
            switch(bombDir){
                case "UNKNOWN":
                  if(X0<W/2){
                     //X0=W-1;
                     sensX=1;
                   }
                   else{
                      
                       sensX=-1;
                   }
                   if(Y0>H/2){
                    sensY=1;
                    
                    }
                    else{
                   
                    sensY=-1;
                    
                    }
                 
                  if(W!=1){
                  moveX(ref X0,ref maxX,ref minX,sensX);
                
                  }
                  else{
                       
                    if(sensY==-1) {
                     sensY*=-1;
                     Y0=0;
                    }
                      
                      moveOnY=true;
                  }
                  if(H!=1){
                      
                 
                 
                    
                  moveY(ref Y0,ref maxY,ref minY,sensY);
                   
                  }
                  
                  Console.Error.WriteLine("Y:"+Y0+" min: "+minY+" max: "+maxY+" sens "+ sensY);
                 
                 minY=H;maxY=0;
                  minX=0;maxX=W;
                break;
                
                case "WARMER":
                
                   properDir=true;
                   if(moveOnY){
                       Console.Error.WriteLine("Y:"+Y0+" min: "+minY+" max: "+maxY+" sens "+ sensY);
                           moveY(ref Y0,ref maxY,ref minY,sensY);
                    }
                   else{
                       moveX(ref X0,ref maxX,ref minX,sensX);
                       moveOnY=(minX==X0&&maxX==X0);
                      if(moveOnY){
                           moveY(ref Y0,ref maxY,ref minY,sensY);
                           properDir=false;
                      }
                   }
                break;
                
                case "COLDER":
                if(properDir){
                    
                    if(moveOnY){
                          reverseY(ref sensY,ref minY,ref maxY,ref Y0, H);
                         // moveY(ref Y0,ref maxY,ref minY,sensY);
                        
                     }
                     else{
                       reverseX(ref sensX,ref minX,ref maxX,ref X0,W);
                       // moveX(ref X0,ref maxX,ref minX,sensX);
                        moveOnY=(minX==X0&&maxX==X0);
                        if(moveOnY){
                          moveY(ref Y0,ref maxY,ref minY,sensY);
                          properDir=false;
                        }
                     }
                     
                }
                else{
                    if(moveOnY){
                        
                    }
                        reverseY(ref sensY,ref minY,ref maxY,ref Y0, H);
                         properDir=true;
                    
                   
                }
                break;
                case "SAME":
                if(!moveOnY)//reverse si on est a égal distance après un warm
                {      reverseX(ref sensX,ref minX,ref maxX,ref X0,W);
                      // moveX(ref X0,ref maxX,ref minX,sensX);
                       moveOnY=(minX==X0&&maxX==X0);
                       if(moveOnY){
                       moveY(ref Y0,ref maxY,ref minY,sensY);
                       properDir=false;
                       }
                }else{
                    
                    
                
                }
                break;
            }
          
           
            Console.WriteLine(X0+" "+Y0);
        }
    }
}
